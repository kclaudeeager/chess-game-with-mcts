<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCTS Chess Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .game-container {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 30px;
            align-items: start;
            max-width: 1200px;
            width: 100%;
        }
        
        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            min-height: 400px;
        }
        
        .chess-board-container {
            text-align: center;
        }
        
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            width: 480px;
            height: 480px;
            background: #8B4513;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .square.light {
            background: #F0D9B5;
            color: #333;
        }
        
        .square.dark {
            background: #B58863;
            color: #333;
        }
        
        .square.selected {
            background: #FFD700 !important;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .square.legal-move {
            background: rgba(0, 255, 0, 0.3) !important;
        }
        
        .square.legal-move::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            background: rgba(0, 255, 0, 0.8);
            border-radius: 50%;
        }
        
        .square:hover {
            transform: scale(1.05);
            z-index: 10;
        }
        
        .status {
            margin: 20px 0;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
            min-height: 24px;
        }
        
        .controls {
            text-align: center;
            margin-top: 20px;
        }
        
        button {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin: 0 10px;
            transition: all 0.3s ease;
        }
        
        button:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        select {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin: 0 10px;
            transition: all 0.3s ease;
        }
        
        select:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        select option {
            background: #2a5298;
            color: white;
        }
        
        .mcts-info h3 {
            margin-bottom: 15px;
            color: #FFD700;
        }
        
        .mcts-info p {
            margin-bottom: 10px;
            line-height: 1.6;
        }
        
        .game-info h3 {
            margin-bottom: 15px;
            color: #FFD700;
        }
        
        .move-history {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
        }
        
        .thinking {
            font-style: italic;
            opacity: 0.8;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
        }
        
        .connection-status.connected {
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid rgba(0, 255, 0, 0.5);
        }
        
        .connection-status.disconnected {
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid rgba(255, 0, 0, 0.5);
        }
        
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            z-index: 1000;
            animation: notificationPop 2s ease-in-out forwards;
            pointer-events: none;
        }
        
        .notification.capture {
            background: rgba(255, 100, 100, 0.9);
        }
        
        .notification.milestone {
            background: rgba(255, 215, 0, 0.9);
            color: #333;
        }
        
        @keyframes notificationPop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">Connecting...</div>
    
    <div class="game-container">
        <div class="info-panel mcts-info">
            <h3>🧠 MCTS Chess Engine</h3>
            <p><strong>Algorithm:</strong> Monte Carlo Tree Search</p>
            <p><strong>Simulations:</strong> ~500 per move</p>
            <p><strong>Time Limit:</strong> 3 seconds</p>
            <p><strong>Search Depth:</strong> Variable</p>
            
            <h4 style="margin-top: 20px; color: #FFD700;">How MCTS Works:</h4>
            <p>1. <strong>Selection:</strong> Navigate tree using UCB1</p>
            <p>2. <strong>Expansion:</strong> Add new nodes</p>
            <p>3. <strong>Simulation:</strong> Random playouts</p>
            <p>4. <strong>Backpropagation:</strong> Update statistics</p>
            
            <p style="margin-top: 15px; font-size: 14px; opacity: 0.9;">
                The AI builds a search tree by exploring promising moves and uses random simulations to evaluate positions. Unlike traditional engines, it doesn't rely on deep tactical analysis but rather statistical sampling.
            </p>
        </div>
        
        <div class="chess-board-container">
            <h1>♔ MCTS Chess Engine ♛</h1>
            <div class="status" id="status">Loading game...</div>
            
            <div class="chess-board" id="chessBoard">
                <!-- Board will be generated by JavaScript -->
            </div>
            
            <div class="controls">
                <button onclick="resetGame()" id="resetBtn">🔄 New Game</button>
                <button onclick="getAIMove()" id="aiMoveBtn" disabled>🤖 AI Move</button>
                <select id="gameModeSelect" onchange="changeGameMode()">
                    <option value="human_vs_ai">Human vs AI</option>
                    <option value="human_vs_human">Human vs Human</option>
                </select>
            </div>
        </div>
        
        <div class="info-panel game-info">
            <h3>📊 Game Status</h3>
            <div id="gameStatus">
                <p><strong>Current Player:</strong> <span id="currentPlayer">White</span></p>
                <p><strong>Check Status:</strong> <span id="checkStatus">None</span></p>
                <p><strong>Game State:</strong> <span id="gameState">In Progress</span></p>
            </div>
            
            <h4 style="margin-top: 20px; color: #FFD700;">Material Balance</h4>
            <div id="materialBalance">
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <div>
                        <strong>White:</strong> <span id="whiteMaterial">39</span> points
                        <div id="whitePieces" style="font-size: 12px; opacity: 0.8;"></div>
                    </div>
                    <div>
                        <strong>Black:</strong> <span id="blackMaterial">39</span> points
                        <div id="blackPieces" style="font-size: 12px; opacity: 0.8;"></div>
                    </div>
                </div>
                <div style="text-align: center;">
                    <strong>Balance:</strong> <span id="materialDifference">Even</span>
                </div>
            </div>
            
            <h4 style="margin-top: 20px; color: #FFD700;">Move History</h4>
            <div class="move-history" id="moveHistory">
                <p>Game started. White to move.</p>
            </div>
            
            <div style="margin-top: 20px; font-size: 14px; opacity: 0.8;">
                <p><strong>Instructions:</strong></p>
                <p>• Click a piece to select it</p>
                <p>• Click a highlighted square to move</p>
                <p id="gameModeInstructions">• You play as White, AI as Black</p>
                <p><strong>Mode:</strong> <span id="currentGameMode">Human vs AI</span></p>
                
                <div style="margin-top: 10px; font-size: 12px;">
                    <p><strong>Piece Values:</strong></p>
                    <p>♕/♛ Queen = 9, ♖/♜ Rook = 5, ♗/♝ Bishop = 3, ♘/♞ Knight = 3, ♙/♟ Pawn = 1</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let gameBoard = null;
        let selectedSquare = null;
        let legalMoves = [];
        let isAIThinking = false;
        let sessionId = null; // Store session ID for backend communication
        let gameMode = 'human_vs_ai'; // Default game mode
        let gameState = {
            current_player: 'white',
            is_check: false,
            is_checkmate: false,
            is_stalemate: false
        };

        // API configuration
        const API_BASE = 'http://localhost:8000/api';
        
        // Sound management
        let audioContext = null;
        let soundEnabled = true;
        
        // Initialize audio context (must be done after user interaction)
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        // Sound generation functions
        function playSound(frequency, duration, type = 'sine', volume = 0.3) {
            if (!soundEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        function playChord(frequencies, duration, volume = 0.2) {
            frequencies.forEach(freq => playSound(freq, duration, 'sine', volume));
        }
        
        // Specific game sounds
        const gameSounds = {
            gameStart: () => playChord([261.63, 329.63, 392.00], 0.8, 0.3), // C major chord
            move: () => playSound(400, 0.15, 'square', 0.2),
            capture: () => {
                playSound(600, 0.1, 'sawtooth', 0.3);
                setTimeout(() => playSound(300, 0.2, 'triangle', 0.2), 100);
            },
            check: () => {
                playSound(800, 0.3, 'triangle', 0.4);
                setTimeout(() => playSound(1000, 0.2, 'sine', 0.3), 150);
            },
            invalidMove: () => {
                playSound(200, 0.3, 'square', 0.3);
                setTimeout(() => playSound(150, 0.2, 'square', 0.2), 150);
            },
            checkmate: () => {
                // Victory fanfare
                const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
                notes.forEach((note, i) => {
                    setTimeout(() => playSound(note, 0.4, 'sine', 0.4), i * 200);
                });
            },
            queenCapture: () => {
                // Special dramatic sound for queen capture
                playSound(1000, 0.2, 'sawtooth', 0.4);
                setTimeout(() => playSound(800, 0.3, 'triangle', 0.3), 100);
                setTimeout(() => playSound(600, 0.4, 'sine', 0.3), 200);
            },
            promotion: () => {
                // Ascending scale for pawn promotion
                const notes = [261.63, 293.66, 329.63, 349.23, 392.00];
                notes.forEach((note, i) => {
                    setTimeout(() => playSound(note, 0.2, 'sine', 0.3), i * 80);
                });
            }
        };
        
        // Chess piece symbols
        const pieceSymbols = {
            'white': {
                'P': '♙', 'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔'
            },
            'black': {
                'P': '♟', 'R': '♜', 'N': '♞', 'B': '♝', 'Q': '♛', 'K': '♚'
            }
        };

        // Initialize the game
        async function initGame() {
            try {
                // Initialize audio on first user interaction
                initAudio();
                
                // Create session with selected game mode
                const createResponse = await fetch(`${API_BASE}/session/create`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        mode: gameMode
                    })
                });
                
                const createData = await createResponse.json();
                if (!createData.success) {
                    throw new Error('Failed to create session');
                }
                
                sessionId = createData.session_id;
                console.log('Created session:', sessionId, 'Mode:', gameMode);
                
                // Get initial game state
                const response = await fetch(`${API_BASE}/game/state?session_id=${sessionId}`);
                if (!response.ok) throw new Error('Failed to get game state');
                
                const data = await response.json();
                
                updateGameState(data);
                updateConnectionStatus(true);
                renderBoard();
                
                updateStatusForGameMode();
                
                // Play game start sound
                setTimeout(() => gameSounds.gameStart(), 300);
                
            } catch (error) {
                console.error('Failed to initialize game:', error);
                updateConnectionStatus(false);
                document.getElementById('status').textContent = 'Failed to connect to chess engine';
            }
        }
        
        function updateStatusForGameMode() {
            if (gameMode === 'human_vs_ai') {
                document.getElementById('status').textContent = 'White to move - Select a piece!';
            } else {
                document.getElementById('status').textContent = 'White to move - Human vs Human mode';
            }
        }
        
        async function changeGameMode() {
            const select = document.getElementById('gameModeSelect');
            gameMode = select.value;
            console.log('Game mode changed to:', gameMode);
            
            // Start a new game with the new mode
            await initGame();
        }

        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            if (connected) {
                status.textContent = '🟢 Connected';
                status.className = 'connection-status connected';
            } else {
                status.textContent = '🔴 Disconnected';
                status.className = 'connection-status disconnected';
            }
        }

        function updateGameState(data) {
            // Handle different response structures
            if (data.board && data.board.board) {
                // GameStateResponse structure (from /api/game/state)
                gameBoard = data.board.board;
                gameState = {
                    current_player: data.board.current_player,
                    is_check: data.is_check,
                    is_checkmate: data.is_checkmate,
                    is_stalemate: data.is_stalemate,
                    material_balance: data.material_balance || data.board.material_balance
                };
            } else if (data.board) {
                // MoveResponse structure (from /api/game/move and /api/game/ai_move)
                gameBoard = data.board.board;
                gameState = {
                    current_player: data.board.current_player,
                    is_check: data.is_check,
                    is_checkmate: data.is_checkmate,
                    is_stalemate: data.is_stalemate,
                    material_balance: data.material_balance || data.board.material_balance
                };
            }
            
            // Legal moves should be at the top level in both response types
            legalMoves = data.legal_moves || [];
            
            console.log('Updated game state:', gameState);
            console.log('Legal moves count:', legalMoves.length);
            console.log('Material balance:', gameState.material_balance);
            
            updateGameInfo();
        }

        function updateGameInfo() {
            document.getElementById('currentPlayer').textContent = 
                gameState.current_player === 'white' ? 'White' : 'Black';
            
            document.getElementById('checkStatus').textContent = 
                gameState.is_check ? 'In Check!' : 'None';
            
            let state = 'In Progress';
            if (gameState.is_checkmate) state = 'Checkmate!';
            else if (gameState.is_stalemate) state = 'Stalemate!';
            
            document.getElementById('gameState').textContent = state;
            
            // Update game mode display
            document.getElementById('currentGameMode').textContent = 
                gameMode === 'human_vs_ai' ? 'Human vs AI' : 'Human vs Human';
            
            document.getElementById('gameModeInstructions').textContent = 
                gameMode === 'human_vs_ai' ? '• You play as White, AI as Black' : '• Both players take turns';
            
            // Update material balance if available
            if (gameState.material_balance) {
                updateMaterialBalance(gameState.material_balance);
            }
            
            // Update AI move button - only show in Human vs AI mode when it's black's turn
            const aiBtn = document.getElementById('aiMoveBtn');
            if (gameMode === 'human_vs_ai') {
                aiBtn.style.display = 'inline-block';
                aiBtn.disabled = gameState.current_player !== 'black' || 
                               gameState.is_checkmate || gameState.is_stalemate || isAIThinking;
            } else {
                aiBtn.style.display = 'none';
            }
        }

        function renderBoard() {
            const boardElement = document.getElementById('chessBoard');
            boardElement.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    // Add piece if present
                    const piece = gameBoard[row][col];
                    if (piece) {
                        square.textContent = pieceSymbols[piece.color][piece.type];
                        
                        // Highlight king in check
                        if (piece.type === 'K' && gameState.is_check && piece.color === gameState.current_player) {
                            square.style.backgroundColor = '#ff6b6b';
                            square.style.animation = 'pulse 1s infinite';
                        }
                    }
                    
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    boardElement.appendChild(square);
                }
            }
            
            updateSquareHighlights();
        }

        function updateSquareHighlights() {
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                square.classList.remove('selected', 'legal-move');
            });
            
            if (selectedSquare) {
                const selectedElement = document.querySelector(
                    `[data-row="${selectedSquare.row}"][data-col="${selectedSquare.col}"]`
                );
                if (selectedElement) {
                    selectedElement.classList.add('selected');
                }
                
                // Highlight legal moves
                const pieceMoves = getPieceMovesAt(selectedSquare.row, selectedSquare.col);
                pieceMoves.forEach(move => {
                    const moveElement = document.querySelector(
                        `[data-row="${move[2]}"][data-col="${move[3]}"]`
                    );
                    if (moveElement) {
                        moveElement.classList.add('legal-move');
                    }
                });
            }
        }

        function getPieceMovesAt(row, col) {
            return legalMoves.filter(move => move[0] === row && move[1] === col);
        }

        async function handleSquareClick(row, col) {
            if (isAIThinking) return;
            if (gameState.is_checkmate || gameState.is_stalemate) return;
            
            // In Human vs Human mode, allow both colors to move
            // In Human vs AI mode, only allow white moves
            if (gameMode === 'human_vs_ai' && gameState.current_player !== 'white') return;
            
            const piece = gameBoard[row][col];
            const currentPlayerColor = gameState.current_player;
            
            console.log(`Square clicked: (${row},${col}), Piece:`, piece, 'Current player:', currentPlayerColor);
            
            if (selectedSquare) {
                // Check if this is a legal move
                const pieceMoves = getPieceMovesAt(selectedSquare.row, selectedSquare.col);
                const isLegalMove = pieceMoves.some(move => move[2] === row && move[3] === col);
                
                console.log('Piece moves from selected square:', pieceMoves);
                console.log('Is legal move to target square:', isLegalMove);
                
                if (isLegalMove) {
                    // Check if this is a capture
                    const capturedPiece = gameBoard[row][col];
                    
                    // Make the move
                    await makeMove(selectedSquare.row, selectedSquare.col, row, col, capturedPiece);
                    selectedSquare = null;
                } else if (piece && piece.color === currentPlayerColor) {
                    // Select new piece of current player's color
                    selectedSquare = {row, col};
                    console.log('Selected new piece:', piece);
                } else {
                    // Deselect
                    selectedSquare = null;
                    console.log('Deselected');
                }
            } else if (piece && piece.color === currentPlayerColor) {
                // Select piece of current player's color
                selectedSquare = {row, col};
                console.log('Selected piece:', piece);
            } else {
                console.log('Cannot select:', piece ? `Wrong color (${piece.color} vs ${currentPlayerColor})` : 'Empty square');
            }
            
            updateSquareHighlights();
        }

        async function makeMove(fromRow, fromCol, toRow, toCol, capturedPiece = null) {
            try {
                // Check if we have a session ID
                if (!sessionId) {
                    console.error('No session ID available');
                    document.getElementById('status').textContent = 'Session error - please refresh the page';
                    return;
                }
                
                console.log(`Making move: (${fromRow},${fromCol}) → (${toRow},${toCol})`);
                if (capturedPiece) {
                    console.log('Capturing piece:', capturedPiece);
                }
                
                // Include session ID as query parameter
                const url = `${API_BASE}/game/move?session_id=${sessionId}`;
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        from_row: fromRow,
                        from_col: fromCol,
                        to_row: toRow,
                        to_col: toCol
                    })
                });
                
                const data = await response.json();
                console.log('Move response:', data);
                
                if (data.success) {
                    // Play appropriate sound based on move type
                    if (capturedPiece) {
                        if (capturedPiece.type === 'Q') {
                            gameSounds.queenCapture();
                        } else {
                            gameSounds.capture();
                        }
                        showCaptureNotification(capturedPiece);
                    } else {
                        gameSounds.move();
                    }
                    
                    updateGameState(data);
                    renderBoard();
                    
                    // Play check sound if opponent is in check
                    if (gameState.is_check) {
                        setTimeout(() => gameSounds.check(), 200);
                    }
                    
                    // Add move to history
                    const playerName = gameState.current_player === 'black' ? 
                        (gameMode === 'human_vs_ai' ? 'White' : 'White Human') : 
                        (gameMode === 'human_vs_ai' ? 'Black' : 'Black Human');
                    addMoveToHistory(fromRow, fromCol, toRow, toCol, playerName, capturedPiece);
                    
                    if (gameState.is_checkmate) {
                        const winner = gameState.current_player === 'white' ? 'Black' : 'White';
                        document.getElementById('status').textContent = `Checkmate! ${winner} wins! 🎉`;
                        showMilestoneNotification('Checkmate!', '👑');
                        setTimeout(() => gameSounds.checkmate(), 300);
                    } else if (gameState.is_stalemate) {
                        document.getElementById('status').textContent = 'Stalemate! Draw! 🤝';
                        showMilestoneNotification('Stalemate!', '🤝');
                    } else if (gameMode === 'human_vs_ai' && gameState.current_player === 'black') {
                        document.getElementById('status').textContent = 'Black to move - AI is thinking...';
                        // Auto-trigger AI move after short delay
                        setTimeout(getAIMove, 500);
                    } else {
                        // Human vs Human or it's white's turn in Human vs AI
                        const currentPlayerName = gameState.current_player === 'white' ? 'White' : 'Black';
                        document.getElementById('status').textContent = `${currentPlayerName} to move - Select a piece!`;
                    }
                } else {
                    console.error('Invalid move:', data);
                    document.getElementById('status').textContent = `Invalid move! ${data.message || 'Try again.'}`;
                    gameSounds.invalidMove();
                    setTimeout(() => {
                        updateStatusForGameMode();
                    }, 2000);
                }
            } catch (error) {
                console.error('Failed to make move:', error);
                updateConnectionStatus(false);
                document.getElementById('status').textContent = 'Move failed - connection error';
                gameSounds.invalidMove();
            }
        }

        async function getAIMove() {
            if (isAIThinking) return;
            if (gameState.current_player !== 'black') return;
            
            // Check if we have a session ID
            if (!sessionId) {
                console.error('No session ID available');
                document.getElementById('status').textContent = 'Session error - please refresh the page';
                return;
            }
            
            isAIThinking = true;
            document.getElementById('status').textContent = 'AI is thinking...';
            document.getElementById('status').classList.add('thinking');
            document.getElementById('aiMoveBtn').disabled = true;
            
            try {
                // Include session ID as query parameter
                const url = `${API_BASE}/game/ai_move?session_id=${sessionId}`;
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const data = await response.json();
                updateGameState(data);
                renderBoard();
                
                // Add AI move to history (we'd need to track the actual move made)
                addMoveToHistory(null, null, null, null, 'Black (AI)');
                
                if (gameState.is_checkmate) {
                    document.getElementById('status').textContent = 'Checkmate! Black wins! 🤖';
                } else if (gameState.is_stalemate) {
                    document.getElementById('status').textContent = 'Stalemate! Draw! 🤝';
                } else {
                    document.getElementById('status').textContent = 'White to move - Your turn!';
                }
                
            } catch (error) {
                console.error('Failed to get AI move:', error);
                updateConnectionStatus(false);
                document.getElementById('status').textContent = 'AI move failed - connection error';
            } finally {
                isAIThinking = false;
                document.getElementById('status').classList.remove('thinking');
                updateGameInfo();
            }
        }

        function addMoveToHistory(fromRow, fromCol, toRow, toCol, player, capturedPiece = null) {
            const historyElement = document.getElementById('moveHistory');
            const moveElement = document.createElement('p');
            
            if (fromRow !== null) {
                const fromSquare = String.fromCharCode(97 + fromCol) + (8 - fromRow);
                const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
                let moveText = `${player}: ${fromSquare} → ${toSquare}`;
                
                if (capturedPiece) {
                    const capturedSymbol = pieceSymbols[capturedPiece.color][capturedPiece.type];
                    moveText += ` (captured ${capturedSymbol})`;
                    moveElement.style.color = '#ffaa44'; // Highlight captures
                }
                
                moveElement.textContent = moveText;
            } else {
                moveElement.textContent = `${player} moved`;
            }
            
            historyElement.appendChild(moveElement);
            historyElement.scrollTop = historyElement.scrollHeight;
        }
        
        function updateMaterialBalance(materialBalance) {
            document.getElementById('whiteMaterial').textContent = materialBalance.white_material;
            document.getElementById('blackMaterial').textContent = materialBalance.black_material;
            
            // Update piece counts
            document.getElementById('whitePieces').textContent = 
                materialBalance.white_pieces ? materialBalance.white_pieces.join(' ') : '';
            document.getElementById('blackPieces').textContent = 
                materialBalance.black_pieces ? materialBalance.black_pieces.join(' ') : '';
            
            // Update balance
            const difference = materialBalance.material_balance;
            let balanceText = 'Even';
            let balanceColor = '#ffffff';
            
            if (difference > 0) {
                balanceText = `White +${difference}`;
                balanceColor = '#90EE90';
            } else if (difference < 0) {
                balanceText = `Black +${Math.abs(difference)}`;
                balanceColor = '#FFB6C1';
            }
            
            const balanceElement = document.getElementById('materialDifference');
            balanceElement.textContent = balanceText;
            balanceElement.style.color = balanceColor;
        }
        
        function showCaptureNotification(capturedPiece) {
            const pieceValues = {
                'P': 1, 'N': 3, 'B': 3, 'R': 5, 'Q': 9, 'K': 0
            };
            
            const pieceValue = pieceValues[capturedPiece.type] || 0;
            const pieceSymbol = pieceSymbols[capturedPiece.color][capturedPiece.type];
            
            let message = `Captured ${pieceSymbol}`;
            if (pieceValue > 0) {
                message += ` (+${pieceValue} point${pieceValue !== 1 ? 's' : ''})`;
            }
            
            // Special messages for valuable pieces
            if (capturedPiece.type === 'Q') {
                message += ' 👑 QUEEN CAPTURED!';
            } else if (capturedPiece.type === 'R') {
                message += ' 🏰 ROOK CAPTURED!';
            }
            
            showNotification(message, 'capture');
        }
        
        function showMilestoneNotification(message, emoji) {
            showNotification(`${emoji} ${message} ${emoji}`, 'milestone');
        }
        
        function showNotification(message, type = 'normal') {
            // Remove any existing notifications
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(n => n.remove());
            
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Remove after animation
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 2000);
        }

        async function resetGame() {
            try {
                // Check if we have a session ID
                if (!sessionId) {
                    console.error('No session ID available');
                    document.getElementById('status').textContent = 'Session error - please refresh the page';
                    return;
                }
                
                // Include session ID as query parameter
                const url = `${API_BASE}/game/reset?session_id=${sessionId}`;
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const data = await response.json();
                updateGameState(data);
                selectedSquare = null;
                isAIThinking = false;
                
                renderBoard();
                
                document.getElementById('status').textContent = 'New game started - White to move!';
                document.getElementById('moveHistory').innerHTML = '<p>Game started. White to move.</p>';
                
            } catch (error) {
                console.error('Failed to reset game:', error);
                updateConnectionStatus(false);
                document.getElementById('status').textContent = 'Reset failed - connection error';
            }
        }

        // Initialize the game when page loads
        window.addEventListener('load', initGame);
        
        // Check connection periodically
        setInterval(async () => {
            try {
                // Include session ID if we have one
                const url = sessionId ? `${API_BASE}/game/state?session_id=${sessionId}` : `${API_BASE}/game/state`;
                const response = await fetch(url);
                updateConnectionStatus(response.ok);
            } catch (error) {
                updateConnectionStatus(false);
            }
        }, 5000);
    </script>
</body>
</html>